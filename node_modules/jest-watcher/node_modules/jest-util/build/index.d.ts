/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/// <reference types="node" />
<<<<<<< HEAD
import { JestFakeTimers as FakeTimers } from '@jest/fake-timers';
import { BufferedConsole, CustomConsole, NullConsole } from '@jest/console';
import { formatTestResults } from '@jest/test-result';
import createDirectory from './createDirectory';
import ErrorWithStack from './ErrorWithStack';
import getFailedSnapshotTests from './getFailedSnapshotTests';
import installCommonGlobals from './installCommonGlobals';
import interopRequireDefault from './interopRequireDefault';
import deepCyclicCopy from './deepCyclicCopy';
import convertDescriptorToString from './convertDescriptorToString';
import * as specialChars from './specialChars';
import replacePathSepForGlob from './replacePathSepForGlob';
import * as preRunMessage from './preRunMessage';
import pluralize from './pluralize';
declare const _default: {
    BufferedConsole: typeof BufferedConsole;
    Console: typeof CustomConsole;
    ErrorWithStack: typeof ErrorWithStack;
    FakeTimers: typeof FakeTimers;
    NullConsole: typeof NullConsole;
    clearLine: (stream: NodeJS.WritableStream) => void;
    convertDescriptorToString: typeof convertDescriptorToString;
    createDirectory: typeof createDirectory;
    deepCyclicCopy: typeof deepCyclicCopy;
    formatTestResults: typeof formatTestResults;
    getCallsite: (level: number, sourceMaps?: Record<string, string> | null | undefined) => import("callsites").CallSite;
    getConsoleOutput: (root: string, verbose: boolean, buffer: import("@jest/console/build/types").LogEntry[]) => string;
    getFailedSnapshotTests: typeof getFailedSnapshotTests;
    installCommonGlobals: typeof installCommonGlobals;
    interopRequireDefault: typeof interopRequireDefault;
    isInteractive: boolean;
    isPromise: (candidate: unknown) => candidate is Promise<unknown>;
    pluralize: typeof pluralize;
    preRunMessage: typeof preRunMessage;
    replacePathSepForGlob: typeof replacePathSepForGlob;
    setGlobal: (globalToMutate: NodeJS.Global | Window, key: string, value: unknown) => void;
    specialChars: typeof specialChars;
    testPathPatternToRegExp: (testPathPattern: string) => RegExp;
};
export = _default;
//# sourceMappingURL=index.d.ts.map
=======

import type {Config} from '@jest/types';
import type {Global} from '@jest/types';

declare const ARROW = ' \u203A ';

declare const CLEAR: string;

export declare function clearLine(stream: NodeJS.WriteStream): void;

export declare function convertDescriptorToString(
  descriptor: Global.BlockNameLike | undefined,
): string;

export declare function createDirectory(path: string): void;

export declare function deepCyclicCopy<T>(
  value: T,
  options?: DeepCyclicCopyOptions,
  cycles?: WeakMap<any, any>,
): T;

declare type DeepCyclicCopyOptions = {
  blacklist?: Set<string>;
  keepPrototype?: boolean;
};

export declare class ErrorWithStack extends Error {
  constructor(
    message: string | undefined,
    callsite: (...args: Array<any>) => unknown,
    stackLimit?: number,
  );
}

export declare function formatTime(
  time: number,
  prefixPower?: number,
  padLeftLength?: number,
): string;

/**
 * Converts a list of globs into a function that matches a path against the
 * globs.
 *
 * Every time picomatch is called, it will parse the glob strings and turn
 * them into regexp instances. Instead of calling picomatch repeatedly with
 * the same globs, we can use this function which will build the picomatch
 * matchers ahead of time and then have an optimized path for determining
 * whether an individual path matches.
 *
 * This function is intended to match the behavior of `micromatch()`.
 *
 * @example
 * const isMatch = globsToMatcher(['*.js', '!*.test.js']);
 * isMatch('pizza.js'); // true
 * isMatch('pizza.test.js'); // false
 */
export declare function globsToMatcher(globs: Array<string>): Matcher;

declare const ICONS: {
  failed: string;
  pending: string;
  success: string;
  todo: string;
};

export declare function installCommonGlobals(
  globalObject: typeof globalThis,
  globals: Config.ConfigGlobals,
): typeof globalThis & Config.ConfigGlobals;

export declare function interopRequireDefault(obj: any): any;

export declare const isInteractive: boolean;

export declare const isPromise: (
  candidate: unknown,
) => candidate is Promise<unknown>;

declare type Matcher = (str: string) => boolean;

export declare function pluralize(word: string, count: number): string;

declare namespace preRunMessage {
  export {print_2 as print, remove};
}
export {preRunMessage};

declare function print_2(stream: NodeJS.WriteStream): void;

declare function remove(stream: NodeJS.WriteStream): void;

export declare function replacePathSepForGlob(path: string): string;

export declare function requireOrImportModule<T>(
  filePath: string,
  applyInteropRequireDefault?: boolean,
): Promise<T>;

export declare function setGlobal(
  globalToMutate: typeof globalThis | Global.Global,
  key: string,
  value: unknown,
): void;

declare namespace specialChars {
  export {ARROW, ICONS, CLEAR};
}
export {specialChars};

export declare function testPathPatternToRegExp(
  testPathPattern: Config.GlobalConfig['testPathPattern'],
): RegExp;

export declare function tryRealpath(path: string): string;

export {};
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
