"use strict";
<<<<<<< HEAD

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

=======
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
<<<<<<< HEAD
const fse = require('fs-extra');

const path = require('path');

const errors = require('./errors');

const populateSWTemplate = require('./populate-sw-template');

module.exports =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* ({
    cacheId,
    cleanupOutdatedCaches,
    clientsClaim,
    directoryIndex,
    handleFetch,
    ignoreURLParametersMatching,
    importScripts,
    manifestEntries,
    modulePathPrefix,
    navigateFallback,
    navigateFallbackBlacklist,
    navigateFallbackWhitelist,
    navigationPreload,
    offlineGoogleAnalytics,
    runtimeCaching,
    skipWaiting,
    swDest,
    workboxSWImport
  }) {
    try {
      yield fse.mkdirp(path.dirname(swDest));
    } catch (error) {
      throw new Error(`${errors['unable-to-make-sw-directory']}. ` + `'${error.message}'`);
    }

    const populatedTemplate = populateSWTemplate({
      cacheId,
      cleanupOutdatedCaches,
      clientsClaim,
      directoryIndex,
      handleFetch,
      ignoreURLParametersMatching,
      importScripts,
      manifestEntries,
      modulePathPrefix,
      navigateFallback,
      navigateFallbackBlacklist,
      navigateFallbackWhitelist,
      navigationPreload,
      offlineGoogleAnalytics,
      runtimeCaching,
      skipWaiting,
      workboxSWImport
    });

    try {
      yield fse.writeFile(swDest, populatedTemplate);
    } catch (error) {
      if (error.code === 'EISDIR') {
        // See https://github.com/GoogleChrome/workbox/issues/612
        throw new Error(errors['sw-write-failure-directory']);
      }

      throw new Error(`${errors['sw-write-failure']}. '${error.message}'`);
    }
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();
=======
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeSWUsingDefaultTemplate = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const upath_1 = __importDefault(require("upath"));
const bundle_1 = require("./bundle");
const errors_1 = require("./errors");
const populate_sw_template_1 = require("./populate-sw-template");
async function writeSWUsingDefaultTemplate({ babelPresetEnvTargets, cacheId, cleanupOutdatedCaches, clientsClaim, directoryIndex, disableDevLogs, ignoreURLParametersMatching, importScripts, inlineWorkboxRuntime, manifestEntries, mode, navigateFallback, navigateFallbackDenylist, navigateFallbackAllowlist, navigationPreload, offlineGoogleAnalytics, runtimeCaching, skipWaiting, sourcemap, swDest, }) {
    const outputDir = upath_1.default.dirname(swDest);
    try {
        await fs_extra_1.default.mkdirp(outputDir);
    }
    catch (error) {
        throw new Error(`${errors_1.errors['unable-to-make-sw-directory']}. ` +
            `'${error instanceof Error && error.message ? error.message : ''}'`);
    }
    const unbundledCode = (0, populate_sw_template_1.populateSWTemplate)({
        cacheId,
        cleanupOutdatedCaches,
        clientsClaim,
        directoryIndex,
        disableDevLogs,
        ignoreURLParametersMatching,
        importScripts,
        manifestEntries,
        navigateFallback,
        navigateFallbackDenylist,
        navigateFallbackAllowlist,
        navigationPreload,
        offlineGoogleAnalytics,
        runtimeCaching,
        skipWaiting,
    });
    try {
        const files = await (0, bundle_1.bundle)({
            babelPresetEnvTargets,
            inlineWorkboxRuntime,
            mode,
            sourcemap,
            swDest,
            unbundledCode,
        });
        const filePaths = [];
        for (const file of files) {
            const filePath = upath_1.default.resolve(file.name);
            filePaths.push(filePath);
            await fs_extra_1.default.writeFile(filePath, file.contents);
        }
        return filePaths;
    }
    catch (error) {
        const err = error;
        if (err.code === 'EISDIR') {
            // See https://github.com/GoogleChrome/workbox/issues/612
            throw new Error(errors_1.errors['sw-write-failure-directory']);
        }
        throw new Error(`${errors_1.errors['sw-write-failure']} '${err.message}'`);
    }
}
exports.writeSWUsingDefaultTemplate = writeSWUsingDefaultTemplate;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
