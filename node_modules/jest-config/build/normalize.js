'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = normalize;

function _crypto() {
<<<<<<< HEAD
  const data = _interopRequireDefault(require('crypto'));

  _crypto = function _crypto() {
=======
  const data = require('crypto');

  _crypto = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

<<<<<<< HEAD
function _path() {
  const data = _interopRequireDefault(require('path'));

  _path = function _path() {
    return data;
  };

  return data;
}

function _glob() {
  const data = _interopRequireDefault(require('glob'));

  _glob = function _glob() {
    return data;
  };

  return data;
}

function _jestValidate() {
  const data = require('jest-validate');

  _jestValidate = function _jestValidate() {
    return data;
  };

  return data;
}

function _jestUtil() {
  const data = require('jest-util');

  _jestUtil = function _jestUtil() {
=======
function path() {
  const data = _interopRequireWildcard(require('path'));

  path = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require('chalk'));

<<<<<<< HEAD
  _chalk = function _chalk() {
=======
  _chalk = function () {
    return data;
  };

  return data;
}

function _deepmerge() {
  const data = _interopRequireDefault(require('deepmerge'));

  _deepmerge = function () {
    return data;
  };

  return data;
}

function _glob() {
  const data = require('glob');

  _glob = function () {
    return data;
  };

  return data;
}

function _gracefulFs() {
  const data = require('graceful-fs');

  _gracefulFs = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

function _micromatch() {
  const data = _interopRequireDefault(require('micromatch'));

<<<<<<< HEAD
  _micromatch = function _micromatch() {
    return data;
  };

  return data;
}

function _realpathNative() {
  const data = require('realpath-native');

  _realpathNative = function _realpathNative() {
    return data;
  };

  return data;
}

function _jestResolve() {
  const data = _interopRequireDefault(require('jest-resolve'));

  _jestResolve = function _jestResolve() {
=======
  _micromatch = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

function _jestRegexUtil() {
  const data = require('jest-regex-util');

<<<<<<< HEAD
  _jestRegexUtil = function _jestRegexUtil() {
=======
  _jestRegexUtil = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

<<<<<<< HEAD
function _jestGetType() {
  const data = _interopRequireDefault(require('jest-get-type'));

  _jestGetType = function _jestGetType() {
=======
function _jestResolve() {
  const data = _interopRequireWildcard(require('jest-resolve'));

  _jestResolve = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

<<<<<<< HEAD
var _validatePattern = _interopRequireDefault(require('./validatePattern'));

var _getMaxWorkers = _interopRequireDefault(require('./getMaxWorkers'));

var _utils = require('./utils');

var _constants = require('./constants');

var _ReporterValidationErrors = require('./ReporterValidationErrors');
=======
function _jestUtil() {
  const data = require('jest-util');

  _jestUtil = function () {
    return data;
  };

  return data;
}

function _jestValidate() {
  const data = require('jest-validate');

  _jestValidate = function () {
    return data;
  };

  return data;
}
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

var _Defaults = _interopRequireDefault(require('./Defaults'));

var _Deprecated = _interopRequireDefault(require('./Deprecated'));

<<<<<<< HEAD
var _setFromArgv = _interopRequireDefault(require('./setFromArgv'));

var _ValidConfig = _interopRequireDefault(require('./ValidConfig'));

=======
var _ReporterValidationErrors = require('./ReporterValidationErrors');

var _ValidConfig = _interopRequireDefault(require('./ValidConfig'));

var _color = require('./color');

var _constants = require('./constants');

var _getMaxWorkers = _interopRequireDefault(require('./getMaxWorkers'));

var _setFromArgv = _interopRequireDefault(require('./setFromArgv'));

var _utils = require('./utils');

var _validatePattern = _interopRequireDefault(require('./validatePattern'));

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

<<<<<<< HEAD
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(
        Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        })
      );
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

const ERROR = `${_utils.BULLET}Validation Error`;
const PRESET_EXTENSIONS = ['.json', '.js'];
const PRESET_NAME = 'jest-preset';

const createConfigError = message =>
  new (_jestValidate()).ValidationError(
    ERROR,
    message,
    _utils.DOCUMENTATION_NOTE
  ); // TS 3.5 forces us to split these into 2

const mergeModuleNameMapperWithPreset = (options, preset) => {
  if (options['moduleNameMapper'] && preset['moduleNameMapper']) {
    options['moduleNameMapper'] = _objectSpread(
      {},
      options['moduleNameMapper'],
      preset['moduleNameMapper'],
      options['moduleNameMapper']
    );
=======
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj};
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const ERROR = `${_utils.BULLET}Validation Error`;
const PRESET_EXTENSIONS = ['.json', '.js', '.cjs', '.mjs'];
const PRESET_NAME = 'jest-preset';

const createConfigError = message =>
  new (_jestValidate().ValidationError)(
    ERROR,
    message,
    _utils.DOCUMENTATION_NOTE
  );

function verifyDirectoryExists(path, key) {
  try {
    const rootStat = (0, _gracefulFs().statSync)(path);

    if (!rootStat.isDirectory()) {
      throw createConfigError(
        `  ${_chalk().default.bold(path)} in the ${_chalk().default.bold(
          key
        )} option is not a directory.`
      );
    }
  } catch (err) {
    if (err instanceof _jestValidate().ValidationError) {
      throw err;
    }

    if (err.code === 'ENOENT') {
      throw createConfigError(
        `  Directory ${_chalk().default.bold(
          path
        )} in the ${_chalk().default.bold(key)} option was not found.`
      );
    } // Not sure in which cases `statSync` can throw, so let's just show the underlying error to the user

    throw createConfigError(
      `  Got an error trying to find ${_chalk().default.bold(
        path
      )} in the ${_chalk().default.bold(key)} option.\n\n  Error was: ${
        err.message
      }`
    );
  }
} // TS 3.5 forces us to split these into 2

const mergeModuleNameMapperWithPreset = (options, preset) => {
  if (options['moduleNameMapper'] && preset['moduleNameMapper']) {
    options['moduleNameMapper'] = {
      ...options['moduleNameMapper'],
      ...preset['moduleNameMapper'],
      ...options['moduleNameMapper']
    };
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  }
};

const mergeTransformWithPreset = (options, preset) => {
  if (options['transform'] && preset['transform']) {
<<<<<<< HEAD
    options['transform'] = _objectSpread(
      {},
      options['transform'],
      preset['transform'],
      options['transform']
=======
    options['transform'] = {
      ...options['transform'],
      ...preset['transform'],
      ...options['transform']
    };
  }
};

const mergeGlobalsWithPreset = (options, preset) => {
  if (options['globals'] && preset['globals']) {
    options['globals'] = (0, _deepmerge().default)(
      preset['globals'],
      options['globals']
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    );
  }
};

<<<<<<< HEAD
const setupPreset = (options, optionsPreset) => {
=======
const setupPreset = async (options, optionsPreset) => {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  let preset;
  const presetPath = (0, _utils.replaceRootDirInPath)(
    options.rootDir,
    optionsPreset
  );

  const presetModule = _jestResolve().default.findNodeModule(
    presetPath.startsWith('.')
      ? presetPath
<<<<<<< HEAD
      : _path().default.join(presetPath, PRESET_NAME),
=======
      : path().join(presetPath, PRESET_NAME),
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    {
      basedir: options.rootDir,
      extensions: PRESET_EXTENSIONS
    }
  );

  try {
<<<<<<< HEAD
    // Force re-evaluation to support multiple projects
    try {
      if (presetModule) {
        delete require.cache[require.resolve(presetModule)];
      }
    } catch (e) {} // @ts-ignore: `presetModule` can be null?

    preset = require(presetModule);
=======
    if (!presetModule) {
      throw new Error(`Cannot find module '${presetPath}'`);
    } // Force re-evaluation to support multiple projects

    try {
      delete require.cache[require.resolve(presetModule)];
    } catch {}

    preset = await (0, _jestUtil().requireOrImportModule)(presetModule);
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  } catch (error) {
    if (error instanceof SyntaxError || error instanceof TypeError) {
      throw createConfigError(
        `  Preset ${_chalk().default.bold(presetPath)} is invalid:\n\n  ${
          error.message
        }\n  ${error.stack}`
      );
    }

<<<<<<< HEAD
    const preset = _jestResolve().default.findNodeModule(presetPath, {
      basedir: options.rootDir
    });

    if (preset) {
      throw createConfigError(
        `  Module ${_chalk().default.bold(
          presetPath
        )} should have "jest-preset.js" or "jest-preset.json" file at the root.`
=======
    if (error.message.includes('Cannot find module')) {
      if (error.message.includes(presetPath)) {
        const preset = _jestResolve().default.findNodeModule(presetPath, {
          basedir: options.rootDir
        });

        if (preset) {
          throw createConfigError(
            `  Module ${_chalk().default.bold(
              presetPath
            )} should have "jest-preset.js" or "jest-preset.json" file at the root.`
          );
        }

        throw createConfigError(
          `  Preset ${_chalk().default.bold(presetPath)} not found.`
        );
      }

      throw createConfigError(
        `  Missing dependency in ${_chalk().default.bold(presetPath)}:\n\n  ${
          error.message
        }\n  ${error.stack}`
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      );
    }

    throw createConfigError(
<<<<<<< HEAD
      `  Preset ${_chalk().default.bold(presetPath)} not found.`
=======
      `  An unknown error occurred in ${_chalk().default.bold(
        presetPath
      )}:\n\n  ${error.message}\n  ${error.stack}`
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    );
  }

  if (options.setupFiles) {
    options.setupFiles = (preset.setupFiles || []).concat(options.setupFiles);
  }

<<<<<<< HEAD
=======
  if (options.setupFilesAfterEnv) {
    options.setupFilesAfterEnv = (preset.setupFilesAfterEnv || []).concat(
      options.setupFilesAfterEnv
    );
  }

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  if (options.modulePathIgnorePatterns && preset.modulePathIgnorePatterns) {
    options.modulePathIgnorePatterns = preset.modulePathIgnorePatterns.concat(
      options.modulePathIgnorePatterns
    );
  }

  mergeModuleNameMapperWithPreset(options, preset);
  mergeTransformWithPreset(options, preset);
<<<<<<< HEAD
  return _objectSpread({}, preset, options);
=======
  mergeGlobalsWithPreset(options, preset);
  return {...preset, ...options};
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
};

const setupBabelJest = options => {
  const transform = options.transform;
  let babelJest;

  if (transform) {
    const customJSPattern = Object.keys(transform).find(pattern => {
      const regex = new RegExp(pattern);
      return regex.test('a.js') || regex.test('a.jsx');
    });
    const customTSPattern = Object.keys(transform).find(pattern => {
      const regex = new RegExp(pattern);
      return regex.test('a.ts') || regex.test('a.tsx');
    });
    [customJSPattern, customTSPattern].forEach(pattern => {
      if (pattern) {
        const customTransformer = transform[pattern];

        if (Array.isArray(customTransformer)) {
          if (customTransformer[0] === 'babel-jest') {
            babelJest = require.resolve('babel-jest');
            customTransformer[0] = babelJest;
          } else if (customTransformer[0].includes('babel-jest')) {
            babelJest = customTransformer[0];
          }
        } else {
          if (customTransformer === 'babel-jest') {
            babelJest = require.resolve('babel-jest');
            transform[pattern] = babelJest;
          } else if (customTransformer.includes('babel-jest')) {
            babelJest = customTransformer;
          }
        }
      }
    });
  } else {
    babelJest = require.resolve('babel-jest');
    options.transform = {
      [_constants.DEFAULT_JS_PATTERN]: babelJest
    };
  }
};

const normalizeCollectCoverageOnlyFrom = (options, key) => {
  const initialCollectCoverageFrom = options[key];
  const collectCoverageOnlyFrom = Array.isArray(initialCollectCoverageFrom)
    ? initialCollectCoverageFrom // passed from argv
    : Object.keys(initialCollectCoverageFrom); // passed from options

  return collectCoverageOnlyFrom.reduce((map, filePath) => {
<<<<<<< HEAD
    filePath = _path().default.resolve(
=======
    filePath = path().resolve(
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      options.rootDir,
      (0, _utils.replaceRootDirInPath)(options.rootDir, filePath)
    );
    map[filePath] = true;
    return map;
  }, Object.create(null));
};

const normalizeCollectCoverageFrom = (options, key) => {
  const initialCollectCoverageFrom = options[key];
  let value;

  if (!initialCollectCoverageFrom) {
    value = [];
  }

  if (!Array.isArray(initialCollectCoverageFrom)) {
    try {
      value = JSON.parse(initialCollectCoverageFrom);
<<<<<<< HEAD
    } catch (e) {}
=======
    } catch {}
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

    if (options[key] && !Array.isArray(value)) {
      value = [initialCollectCoverageFrom];
    }
  } else {
    value = initialCollectCoverageFrom;
  }

  if (value) {
    value = value.map(filePath =>
      filePath.replace(/^(!?)(<rootDir>\/)(.*)/, '$1$3')
    );
  }

  return value;
};

const normalizeUnmockedModulePathPatterns = (
  options,
  key // _replaceRootDirTags is specifically well-suited for substituting
<<<<<<< HEAD
=======
) =>
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  // <rootDir> in paths (it deals with properly interpreting relative path
  // separators, etc).
  //
  // For patterns, direct global substitution is far more ideal, so we
  // special case substitutions for patterns here.
<<<<<<< HEAD
) =>
=======
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  options[key].map(pattern =>
    (0, _jestRegexUtil().replacePathSepForRegex)(
      pattern.replace(/<rootDir>/g, options.rootDir)
    )
  );

const normalizePreprocessor = options => {
  if (options.scriptPreprocessor && options.transform) {
    throw createConfigError(`  Options: ${_chalk().default.bold(
      'scriptPreprocessor'
    )} and ${_chalk().default.bold('transform')} cannot be used together.
  Please change your configuration to only use ${_chalk().default.bold(
    'transform'
  )}.`);
  }

  if (options.preprocessorIgnorePatterns && options.transformIgnorePatterns) {
    throw createConfigError(`  Options ${_chalk().default.bold(
      'preprocessorIgnorePatterns'
    )} and ${_chalk().default.bold(
      'transformIgnorePatterns'
    )} cannot be used together.
  Please change your configuration to only use ${_chalk().default.bold(
    'transformIgnorePatterns'
  )}.`);
  }

  if (options.scriptPreprocessor) {
    options.transform = {
      '.*': options.scriptPreprocessor
    };
  }

  if (options.preprocessorIgnorePatterns) {
    options.transformIgnorePatterns = options.preprocessorIgnorePatterns;
  }

  delete options.scriptPreprocessor;
  delete options.preprocessorIgnorePatterns;
  return options;
};

const normalizeMissingOptions = (options, configPath, projectIndex) => {
  if (!options.name) {
<<<<<<< HEAD
    options.name = _crypto()
      .default.createHash('md5')
=======
    options.name = (0, _crypto().createHash)('md5')
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      .update(options.rootDir) // In case we load config from some path that has the same root dir
      .update(configPath || '')
      .update(String(projectIndex))
      .digest('hex');
  }

  if (!options.setupFiles) {
    options.setupFiles = [];
  }

  return options;
};

const normalizeRootDir = options => {
  // Assert that there *is* a rootDir
<<<<<<< HEAD
  if (!options.hasOwnProperty('rootDir')) {
=======
  if (!options.rootDir) {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    throw createConfigError(
      `  Configuration option ${_chalk().default.bold(
        'rootDir'
      )} must be specified.`
    );
  }

<<<<<<< HEAD
  options.rootDir = _path().default.normalize(options.rootDir);

  try {
    // try to resolve windows short paths, ignoring errors (permission errors, mostly)
    options.rootDir = (0, _realpathNative().sync)(options.rootDir);
  } catch (e) {
    // ignored
  }

  return options;
=======
  options.rootDir = path().normalize(options.rootDir);

  try {
    // try to resolve windows short paths, ignoring errors (permission errors, mostly)
    options.rootDir = (0, _jestUtil().tryRealpath)(options.rootDir);
  } catch {
    // ignored
  }

  verifyDirectoryExists(options.rootDir, 'rootDir');
  return {...options, rootDir: options.rootDir};
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
};

const normalizeReporters = options => {
  const reporters = options.reporters;

  if (!reporters || !Array.isArray(reporters)) {
    return options;
  }

  (0, _ReporterValidationErrors.validateReporters)(reporters);
  options.reporters = reporters.map(reporterConfig => {
    const normalizedReporterConfig =
      typeof reporterConfig === 'string' // if reporter config is a string, we wrap it in an array
        ? // and pass an empty object for options argument, to normalize
<<<<<<< HEAD
=======
          // the shape.
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
          [reporterConfig, {}]
        : reporterConfig;
    const reporterPath = (0, _utils.replaceRootDirInPath)(
      options.rootDir,
      normalizedReporterConfig[0]
    );

    if (reporterPath !== _constants.DEFAULT_REPORTER_LABEL) {
      const reporter = _jestResolve().default.findNodeModule(reporterPath, {
        basedir: options.rootDir
      });

      if (!reporter) {
<<<<<<< HEAD
        throw new Error(
          `Could not resolve a module for a custom reporter.\n` +
=======
        throw new (_jestResolve().default.ModuleNotFoundError)(
          'Could not resolve a module for a custom reporter.\n' +
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
            `  Module name: ${reporterPath}`
        );
      }

      normalizedReporterConfig[0] = reporter;
    }

    return normalizedReporterConfig;
  });
  return options;
};

const buildTestPathPattern = argv => {
  const patterns = [];

  if (argv._) {
    patterns.push(...argv._);
  }

  if (argv.testPathPattern) {
    patterns.push(...argv.testPathPattern);
  }

  const replacePosixSep = pattern => {
<<<<<<< HEAD
    if (_path().default.sep === '/') {
      return pattern;
    }

    return pattern.replace(/\//g, '\\\\');
=======
    // yargs coerces positional args into numbers
    const patternAsString = pattern.toString();

    if (path().sep === '/') {
      return patternAsString;
    }

    return patternAsString.replace(/\//g, '\\\\');
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  };

  const testPathPattern = patterns.map(replacePosixSep).join('|');

  if ((0, _validatePattern.default)(testPathPattern)) {
    return testPathPattern;
  } else {
    showTestPathPatternError(testPathPattern);
    return '';
  }
};

const showTestPathPatternError = testPathPattern => {
<<<<<<< HEAD
  (0, _jestUtil().clearLine)(process.stdout);
  console.log(
    _chalk().default.red(
      `  Invalid testPattern ${testPathPattern} supplied. ` +
        `Running all tests instead.`
=======
  (0, _jestUtil().clearLine)(process.stdout); // eslint-disable-next-line no-console

  console.log(
    _chalk().default.red(
      `  Invalid testPattern ${testPathPattern} supplied. ` +
        'Running all tests instead.'
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    )
  );
};

<<<<<<< HEAD
function normalize(options, argv, configPath, projectIndex = Infinity) {
  const _validate = (0, _jestValidate().validate)(options, {
      comment: _utils.DOCUMENTATION_NOTE,
      deprecatedConfig: _Deprecated.default,
      exampleConfig: _ValidConfig.default,
      recursiveBlacklist: [
        'collectCoverageOnlyFrom', // 'coverageThreshold' allows to use 'global' and glob strings on the same
=======
function validateExtensionsToTreatAsEsm(extensionsToTreatAsEsm) {
  if (!extensionsToTreatAsEsm || extensionsToTreatAsEsm.length === 0) {
    return;
  }

  function printConfig(opts) {
    const string = opts.map(ext => `'${ext}'`).join(', ');
    return _chalk().default.bold(`extensionsToTreatAsEsm: [${string}]`);
  }

  const extensionWithoutDot = extensionsToTreatAsEsm.some(
    ext => !ext.startsWith('.')
  );

  if (extensionWithoutDot) {
    throw createConfigError(`  Option: ${printConfig(
      extensionsToTreatAsEsm
    )} includes a string that does not start with a period (${_chalk().default.bold(
      '.'
    )}).
  Please change your configuration to ${printConfig(
    extensionsToTreatAsEsm.map(ext => (ext.startsWith('.') ? ext : `.${ext}`))
  )}.`);
  }

  if (extensionsToTreatAsEsm.includes('.js')) {
    throw createConfigError(
      `  Option: ${printConfig(
        extensionsToTreatAsEsm
      )} includes ${_chalk().default.bold(
        "'.js'"
      )} which is always inferred based on ${_chalk().default.bold(
        'type'
      )} in its nearest ${_chalk().default.bold('package.json')}.`
    );
  }

  if (extensionsToTreatAsEsm.includes('.cjs')) {
    throw createConfigError(
      `  Option: ${printConfig(
        extensionsToTreatAsEsm
      )} includes ${_chalk().default.bold(
        "'.cjs'"
      )} which is always treated as CommonJS.`
    );
  }

  if (extensionsToTreatAsEsm.includes('.mjs')) {
    throw createConfigError(
      `  Option: ${printConfig(
        extensionsToTreatAsEsm
      )} includes ${_chalk().default.bold(
        "'.mjs'"
      )} which is always treated as an ECMAScript Module.`
    );
  }
}

async function normalize(
  initialOptions,
  argv,
  configPath,
  projectIndex = Infinity
) {
  var _options$haste, _argv$_;

  const {hasDeprecationWarnings} = (0, _jestValidate().validate)(
    initialOptions,
    {
      comment: _utils.DOCUMENTATION_NOTE,
      deprecatedConfig: _Deprecated.default,
      exampleConfig: _ValidConfig.default,
      recursiveDenylist: [
        'collectCoverageOnlyFrom', // 'coverageThreshold' allows to use 'global' and glob strings on the same
        // level, there's currently no way we can deal with such config
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
        'coverageThreshold',
        'globals',
        'moduleNameMapper',
        'testEnvironmentOptions',
        'transform'
      ]
<<<<<<< HEAD
    }),
    hasDeprecationWarnings = _validate.hasDeprecationWarnings;

  options = normalizePreprocessor(
    normalizeReporters(
      normalizeMissingOptions(
        normalizeRootDir((0, _setFromArgv.default)(options, argv)),
=======
    }
  );
  let options = normalizePreprocessor(
    normalizeReporters(
      normalizeMissingOptions(
        normalizeRootDir((0, _setFromArgv.default)(initialOptions, argv)),
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
        configPath,
        projectIndex
      )
    )
  );

  if (options.preset) {
<<<<<<< HEAD
    options = setupPreset(options, options.preset);
=======
    options = await setupPreset(options, options.preset);
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  }

  if (!options.setupFilesAfterEnv) {
    options.setupFilesAfterEnv = [];
  }

  if (
    options.setupTestFrameworkScriptFile &&
    options.setupFilesAfterEnv.length > 0
  ) {
    throw createConfigError(`  Options: ${_chalk().default.bold(
      'setupTestFrameworkScriptFile'
    )} and ${_chalk().default.bold(
      'setupFilesAfterEnv'
    )} cannot be used together.
  Please change your configuration to only use ${_chalk().default.bold(
    'setupFilesAfterEnv'
  )}.`);
  }

  if (options.setupTestFrameworkScriptFile) {
    options.setupFilesAfterEnv.push(options.setupTestFrameworkScriptFile);
  }

<<<<<<< HEAD
  options.testEnvironment = (0, _utils.getTestEnvironment)({
    rootDir: options.rootDir,
    testEnvironment:
      options.testEnvironment || _Defaults.default.testEnvironment
=======
  options.testEnvironment = (0, _jestResolve().resolveTestEnvironment)({
    requireResolveFunction: require.resolve,
    rootDir: options.rootDir,
    testEnvironment:
      options.testEnvironment ||
      require.resolve(_Defaults.default.testEnvironment)
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  });

  if (!options.roots && options.testPathDirs) {
    options.roots = options.testPathDirs;
    delete options.testPathDirs;
  }

  if (!options.roots) {
    options.roots = [options.rootDir];
  }

<<<<<<< HEAD
  if (!options.testRunner || options.testRunner === 'jasmine2') {
=======
  if (
    !options.testRunner ||
    options.testRunner === 'circus' ||
    options.testRunner === 'jest-circus'
  ) {
    options.testRunner = require.resolve('jest-circus/runner');
  } else if (options.testRunner === 'jasmine2') {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    options.testRunner = require.resolve('jest-jasmine2');
  }

  if (!options.coverageDirectory) {
<<<<<<< HEAD
    options.coverageDirectory = _path().default.resolve(
      options.rootDir,
      'coverage'
    );
=======
    options.coverageDirectory = path().resolve(options.rootDir, 'coverage');
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  }

  setupBabelJest(options); // TODO: Type this properly

<<<<<<< HEAD
  const newOptions = _objectSpread({}, _Defaults.default);
=======
  const newOptions = {..._Defaults.default};
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

  if (options.resolver) {
    newOptions.resolver = (0, _utils.resolve)(null, {
      filePath: options.resolver,
      key: 'resolver',
      rootDir: options.rootDir
    });
  }

<<<<<<< HEAD
=======
  validateExtensionsToTreatAsEsm(options.extensionsToTreatAsEsm);

  if (options.watchman == null) {
    options.watchman = _Defaults.default.watchman;
  }

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  const optionKeys = Object.keys(options);
  optionKeys.reduce((newOptions, key) => {
    // The resolver has been resolved separately; skip it
    if (key === 'resolver') {
      return newOptions;
    } // This is cheating, because it claims that all keys of InitialOptions are Required.
    // We only really know it's Required for oldOptions[key], not for oldOptions.someOtherKey,
    // so oldOptions[key] is the only way it should be used.

    const oldOptions = options;
    let value;

    switch (key) {
      case 'collectCoverageOnlyFrom':
        value = normalizeCollectCoverageOnlyFrom(oldOptions, key);
        break;

      case 'setupFiles':
      case 'setupFilesAfterEnv':
      case 'snapshotSerializers':
        {
          const option = oldOptions[key];
          value =
            option &&
            option.map(filePath =>
              (0, _utils.resolve)(newOptions.resolver, {
                filePath,
                key,
                rootDir: options.rootDir
              })
            );
        }
        break;

      case 'modulePaths':
      case 'roots':
        {
          const option = oldOptions[key];
          value =
            option &&
            option.map(filePath =>
<<<<<<< HEAD
              _path().default.resolve(
=======
              path().resolve(
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
                options.rootDir,
                (0, _utils.replaceRootDirInPath)(options.rootDir, filePath)
              )
            );
        }
        break;

      case 'collectCoverageFrom':
        value = normalizeCollectCoverageFrom(oldOptions, key);
        break;

      case 'cacheDirectory':
      case 'coverageDirectory':
        {
          const option = oldOptions[key];
          value =
            option &&
<<<<<<< HEAD
            _path().default.resolve(
=======
            path().resolve(
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
              options.rootDir,
              (0, _utils.replaceRootDirInPath)(options.rootDir, option)
            );
        }
        break;

      case 'dependencyExtractor':
      case 'globalSetup':
      case 'globalTeardown':
      case 'moduleLoader':
      case 'snapshotResolver':
      case 'testResultsProcessor':
      case 'testRunner':
      case 'filter':
        {
          const option = oldOptions[key];
          value =
            option &&
            (0, _utils.resolve)(newOptions.resolver, {
              filePath: option,
              key,
              rootDir: options.rootDir
            });
        }
        break;

      case 'runner':
        {
          const option = oldOptions[key];
          value =
            option &&
<<<<<<< HEAD
            (0, _utils.getRunner)(newOptions.resolver, {
              filePath: option,
=======
            (0, _jestResolve().resolveRunner)(newOptions.resolver, {
              filePath: option,
              requireResolveFunction: require.resolve,
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
              rootDir: options.rootDir
            });
        }
        break;

      case 'prettierPath':
        {
          // We only want this to throw if "prettierPath" is explicitly passed
          // from config or CLI, and the requested path isn't found. Otherwise we
          // set it to null and throw an error lazily when it is used.
          const option = oldOptions[key];
          value =
            option &&
            (0, _utils.resolve)(newOptions.resolver, {
              filePath: option,
              key,
              optional: option === _Defaults.default[key],
              rootDir: options.rootDir
            });
        }
        break;

      case 'moduleNameMapper':
        const moduleNameMapper = oldOptions[key];
        value =
          moduleNameMapper &&
          Object.keys(moduleNameMapper).map(regex => {
            const item = moduleNameMapper && moduleNameMapper[regex];
            return (
              item && [
                regex,
                (0, _utils._replaceRootDirTags)(options.rootDir, item)
              ]
            );
          });
        break;

      case 'transform':
        const transform = oldOptions[key];
        value =
          transform &&
          Object.keys(transform).map(regex => {
            const transformElement = transform[regex];
            return [
              regex,
              (0, _utils.resolve)(newOptions.resolver, {
                filePath: Array.isArray(transformElement)
                  ? transformElement[0]
                  : transformElement,
                key,
                rootDir: options.rootDir
              }),
<<<<<<< HEAD
              ...(Array.isArray(transformElement) ? [transformElement[1]] : [])
=======
              Array.isArray(transformElement) ? transformElement[1] : {}
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
            ];
          });
        break;

      case 'coveragePathIgnorePatterns':
      case 'modulePathIgnorePatterns':
      case 'testPathIgnorePatterns':
      case 'transformIgnorePatterns':
      case 'watchPathIgnorePatterns':
      case 'unmockedModulePathPatterns':
        value = normalizeUnmockedModulePathPatterns(oldOptions, key);
        break;

      case 'haste':
<<<<<<< HEAD
        value = _objectSpread({}, oldOptions[key]);
=======
        value = {...oldOptions[key]};
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

        if (value.hasteImplModulePath != null) {
          const resolvedHasteImpl = (0, _utils.resolve)(newOptions.resolver, {
            filePath: (0, _utils.replaceRootDirInPath)(
              options.rootDir,
              value.hasteImplModulePath
            ),
            key: 'haste.hasteImplModulePath',
            rootDir: options.rootDir
          });
          value.hasteImplModulePath = resolvedHasteImpl || undefined;
        }

        break;

      case 'projects':
        value = (oldOptions[key] || [])
          .map(project =>
            typeof project === 'string'
              ? (0, _utils._replaceRootDirTags)(options.rootDir, project)
              : project
          )
          .reduce((projects, project) => {
            // Project can be specified as globs. If a glob matches any files,
            // We expand it to these paths. If not, we keep the original path
            // for the future resolution.
            const globMatches =
<<<<<<< HEAD
              typeof project === 'string' ? _glob().default.sync(project) : [];
=======
              typeof project === 'string' ? (0, _glob().sync)(project) : [];
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
            return projects.concat(globMatches.length ? globMatches : project);
          }, []);
        break;

      case 'moduleDirectories':
      case 'testMatch':
        {
          const replacedRootDirTags = (0, _utils._replaceRootDirTags)(
            (0, _utils.escapeGlobCharacters)(options.rootDir),
            oldOptions[key]
          );

          if (replacedRootDirTags) {
            value = Array.isArray(replacedRootDirTags)
              ? replacedRootDirTags.map(_jestUtil().replacePathSepForGlob)
              : (0, _jestUtil().replacePathSepForGlob)(replacedRootDirTags);
          } else {
            value = replacedRootDirTags;
          }
        }
        break;

      case 'testRegex':
        {
          const option = oldOptions[key];
          value = option
            ? (Array.isArray(option) ? option : [option]).map(
                _jestRegexUtil().replacePathSepForRegex
              )
            : [];
        }
        break;

      case 'moduleFileExtensions': {
        value = oldOptions[key];

        if (
          Array.isArray(value) && // If it's the wrong type, it can throw at a later time
          (options.runner === undefined ||
            options.runner === _Defaults.default.runner) && // Only require 'js' for the default jest-runner
          !value.includes('js')
        ) {
          const errorMessage =
<<<<<<< HEAD
            `  moduleFileExtensions must include 'js':\n` +
            `  but instead received:\n` +
=======
            "  moduleFileExtensions must include 'js':\n" +
            '  but instead received:\n' +
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
            `    ${_chalk().default.bold.red(JSON.stringify(value))}`; // If `js` is not included, any dependency Jest itself injects into
          // the environment, like jasmine or sourcemap-support, will need to
          // `require` its modules with a file extension. This is not plausible
          // in the long run, so it's way easier to just fail hard early.
          // We might consider throwing if `json` is missing as well, as it's a
          // fair assumption from modules that they can do
          // `require('some-package/package') without the trailing `.json` as it
          // works in Node normally.

          throw createConfigError(
            errorMessage +
              "\n  Please change your configuration to include 'js'."
          );
        }

        break;
      }

      case 'bail': {
        const bail = oldOptions[key];

        if (typeof bail === 'boolean') {
          value = bail ? 1 : 0;
        } else if (typeof bail === 'string') {
          value = 1; // If Jest is invoked as `jest --bail someTestPattern` then need to
          // move the pattern from the `bail` configuration and into `argv._`
          // to be processed as an extra parameter

          argv._.push(bail);
        } else {
          value = oldOptions[key];
        }

        break;
      }

      case 'displayName': {
        const displayName = oldOptions[key];
<<<<<<< HEAD

        if (typeof displayName === 'string') {
          value = displayName;
          break;
        }
        /**
         * Ensuring that displayName shape is correct here so that the
         * reporters can trust the shape of the data
         * TODO: Normalize "displayName" such that given a config option
         * {
         *  "displayName": "Test"
         * }
         * becomes
         * {
         *   displayName: {
         *     name: "Test",
         *     color: "white"
         *   }
         * }
         *
         * This can't be done now since this will be a breaking change
         * for custom reporters
         */

        if ((0, _jestGetType().default)(displayName) === 'object') {
          const errorMessage =
            `  Option "${_chalk().default.bold(
              'displayName'
            )}" must be of type:\n\n` +
            '  {\n' +
            '    name: string;\n' +
            '    color: string;\n' +
            '  }\n';
          const name = displayName.name,
            color = displayName.color;
=======
        /**
         * Ensuring that displayName shape is correct here so that the
         * reporters can trust the shape of the data
         */

        if (typeof displayName === 'object') {
          const {name, color} = displayName;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

          if (
            !name ||
            !color ||
            typeof name !== 'string' ||
            typeof color !== 'string'
          ) {
<<<<<<< HEAD
            throw createConfigError(errorMessage);
          }
        }

        value = oldOptions[key];
=======
            const errorMessage =
              `  Option "${_chalk().default.bold(
                'displayName'
              )}" must be of type:\n\n` +
              '  {\n' +
              '    name: string;\n' +
              '    color: string;\n' +
              '  }\n';
            throw createConfigError(errorMessage);
          }

          value = oldOptions[key];
        } else {
          value = {
            color: (0, _color.getDisplayNameColor)(options.runner),
            name: displayName
          };
        }

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
        break;
      }

      case 'testTimeout': {
        if (oldOptions[key] < 0) {
          throw createConfigError(
            `  Option "${_chalk().default.bold(
              'testTimeout'
            )}" must be a natural number.`
          );
        }

        value = oldOptions[key];
        break;
      }

      case 'automock':
<<<<<<< HEAD
      case 'browser':
=======
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      case 'cache':
      case 'changedSince':
      case 'changedFilesWithAncestor':
      case 'clearMocks':
      case 'collectCoverage':
<<<<<<< HEAD
=======
      case 'coverageProvider':
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      case 'coverageReporters':
      case 'coverageThreshold':
      case 'detectLeaks':
      case 'detectOpenHandles':
      case 'errorOnDeprecated':
      case 'expand':
<<<<<<< HEAD
=======
      case 'extensionsToTreatAsEsm':
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      case 'extraGlobals':
      case 'globals':
      case 'findRelatedTests':
      case 'forceCoverageMatch':
      case 'forceExit':
<<<<<<< HEAD
=======
      case 'injectGlobals':
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      case 'lastCommit':
      case 'listTests':
      case 'logHeapUsage':
      case 'maxConcurrency':
<<<<<<< HEAD
      case 'mapCoverage':
=======
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      case 'name':
      case 'noStackTrace':
      case 'notify':
      case 'notifyMode':
      case 'onlyChanged':
<<<<<<< HEAD
=======
      case 'onlyFailures':
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      case 'outputFile':
      case 'passWithNoTests':
      case 'replname':
      case 'reporters':
      case 'resetMocks':
      case 'resetModules':
      case 'restoreMocks':
      case 'rootDir':
      case 'runTestsByPath':
      case 'silent':
      case 'skipFilter':
      case 'skipNodeResolution':
<<<<<<< HEAD
=======
      case 'slowTestThreshold':
      case 'snapshotFormat':
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      case 'testEnvironment':
      case 'testEnvironmentOptions':
      case 'testFailureExitCode':
      case 'testLocationInResults':
      case 'testNamePattern':
      case 'testURL':
      case 'timers':
      case 'useStderr':
      case 'verbose':
      case 'watch':
      case 'watchAll':
      case 'watchman':
        value = oldOptions[key];
        break;

      case 'watchPlugins':
        value = (oldOptions[key] || []).map(watchPlugin => {
          if (typeof watchPlugin === 'string') {
            return {
              config: {},
<<<<<<< HEAD
              path: (0, _utils.getWatchPlugin)(newOptions.resolver, {
                filePath: watchPlugin,
                rootDir: options.rootDir
              })
=======
              path: (0, _jestResolve().resolveWatchPlugin)(
                newOptions.resolver,
                {
                  filePath: watchPlugin,
                  requireResolveFunction: require.resolve,
                  rootDir: options.rootDir
                }
              )
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
            };
          } else {
            return {
              config: watchPlugin[1] || {},
<<<<<<< HEAD
              path: (0, _utils.getWatchPlugin)(newOptions.resolver, {
                filePath: watchPlugin[0],
                rootDir: options.rootDir
              })
=======
              path: (0, _jestResolve().resolveWatchPlugin)(
                newOptions.resolver,
                {
                  filePath: watchPlugin[0],
                  requireResolveFunction: require.resolve,
                  rootDir: options.rootDir
                }
              )
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
            };
          }
        });
        break;
<<<<<<< HEAD
    } // @ts-ignore: automock is missing in GlobalConfig, so what
=======
    } // @ts-expect-error: automock is missing in GlobalConfig, so what
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

    newOptions[key] = value;
    return newOptions;
  }, newOptions);

<<<<<<< HEAD
  try {
    // try to resolve windows short paths, ignoring errors (permission errors, mostly)
    newOptions.cwd = (0, _realpathNative().sync)(process.cwd());
  } catch (e) {
    // ignored
  }

  newOptions.testSequencer = (0, _utils.getSequencer)(newOptions.resolver, {
    filePath: options.testSequencer || _Defaults.default.testSequencer,
    rootDir: options.rootDir
  });
  newOptions.nonFlagArgs = argv._;
=======
  if (
    options.watchman &&
    (_options$haste = options.haste) !== null &&
    _options$haste !== void 0 &&
    _options$haste.enableSymlinks
  ) {
    throw new (_jestValidate().ValidationError)(
      'Validation Error',
      'haste.enableSymlinks is incompatible with watchman',
      'Either set haste.enableSymlinks to false or do not use watchman'
    );
  }

  newOptions.roots.forEach((root, i) => {
    verifyDirectoryExists(root, `roots[${i}]`);
  });

  try {
    // try to resolve windows short paths, ignoring errors (permission errors, mostly)
    newOptions.cwd = (0, _jestUtil().tryRealpath)(process.cwd());
  } catch {
    // ignored
  }

  newOptions.testSequencer = (0, _jestResolve().resolveSequencer)(
    newOptions.resolver,
    {
      filePath:
        options.testSequencer ||
        require.resolve(_Defaults.default.testSequencer),
      requireResolveFunction: require.resolve,
      rootDir: options.rootDir
    }
  );

  if (newOptions.runner === _Defaults.default.runner) {
    newOptions.runner = require.resolve(newOptions.runner);
  }

  newOptions.nonFlagArgs =
    (_argv$_ = argv._) === null || _argv$_ === void 0
      ? void 0
      : _argv$_.map(arg => `${arg}`);
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  newOptions.testPathPattern = buildTestPathPattern(argv);
  newOptions.json = !!argv.json;
  newOptions.testFailureExitCode = parseInt(newOptions.testFailureExitCode, 10);

  if (
    newOptions.lastCommit ||
    newOptions.changedFilesWithAncestor ||
    newOptions.changedSince
  ) {
    newOptions.onlyChanged = true;
  }

  if (argv.all) {
    newOptions.onlyChanged = false;
<<<<<<< HEAD
=======
    newOptions.onlyFailures = false;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  } else if (newOptions.testPathPattern) {
    // When passing a test path pattern we don't want to only monitor changed
    // files unless `--watch` is also passed.
    newOptions.onlyChanged = newOptions.watch;
  }

<<<<<<< HEAD
=======
  if (!newOptions.onlyChanged) {
    newOptions.onlyChanged = false;
  }

  if (!newOptions.lastCommit) {
    newOptions.lastCommit = false;
  }

  if (!newOptions.onlyFailures) {
    newOptions.onlyFailures = false;
  }

  if (!newOptions.watchAll) {
    newOptions.watchAll = false;
  } // as unknown since it can happen. We really need to fix the types here

  if (newOptions.moduleNameMapper === _Defaults.default.moduleNameMapper) {
    newOptions.moduleNameMapper = [];
  }

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  newOptions.updateSnapshot =
    argv.ci && !argv.updateSnapshot
      ? 'none'
      : argv.updateSnapshot
      ? 'all'
      : 'new';
  newOptions.maxConcurrency = parseInt(newOptions.maxConcurrency, 10);
  newOptions.maxWorkers = (0, _getMaxWorkers.default)(argv, options);

  if (newOptions.testRegex.length && options.testMatch) {
    throw createConfigError(
      `  Configuration options ${_chalk().default.bold('testMatch')} and` +
        ` ${_chalk().default.bold('testRegex')} cannot be used together.`
    );
  }

  if (newOptions.testRegex.length && !options.testMatch) {
    // Prevent the default testMatch conflicting with any explicitly
    // configured `testRegex` value
    newOptions.testMatch = [];
  } // If argv.json is set, coverageReporters shouldn't print a text report.

  if (argv.json) {
    newOptions.coverageReporters = (newOptions.coverageReporters || []).filter(
      reporter => reporter !== 'text'
    );
  } // If collectCoverage is enabled while using --findRelatedTests we need to
  // avoid having false negatives in the generated coverage report.
  // The following: `--findRelatedTests '/rootDir/file1.js' --coverage`
  // Is transformed to: `--findRelatedTests '/rootDir/file1.js' --coverage --collectCoverageFrom 'file1.js'`
  // where arguments to `--collectCoverageFrom` should be globs (or relative
  // paths to the rootDir)

  if (newOptions.collectCoverage && argv.findRelatedTests) {
<<<<<<< HEAD
    let collectCoverageFrom = argv._.map(filename => {
      filename = (0, _utils.replaceRootDirInPath)(options.rootDir, filename);
      return _path().default.isAbsolute(filename)
        ? _path().default.relative(options.rootDir, filename)
=======
    let collectCoverageFrom = newOptions.nonFlagArgs.map(filename => {
      filename = (0, _utils.replaceRootDirInPath)(options.rootDir, filename);
      return path().isAbsolute(filename)
        ? path().relative(options.rootDir, filename)
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
        : filename;
    }); // Don't override existing collectCoverageFrom options

    if (newOptions.collectCoverageFrom) {
      collectCoverageFrom = collectCoverageFrom.reduce((patterns, filename) => {
        if (
<<<<<<< HEAD
          !_micromatch().default.some(
            (0, _jestUtil().replacePathSepForGlob)(
              _path().default.relative(options.rootDir, filename)
            ),
            newOptions.collectCoverageFrom
          )
=======
          (0, _micromatch().default)(
            [
              (0, _jestUtil().replacePathSepForGlob)(
                path().relative(options.rootDir, filename)
              )
            ],
            newOptions.collectCoverageFrom
          ).length === 0
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
        ) {
          return patterns;
        }

        return [...patterns, filename];
      }, newOptions.collectCoverageFrom);
    }

    newOptions.collectCoverageFrom = collectCoverageFrom;
<<<<<<< HEAD
=======
  } else if (!newOptions.collectCoverageFrom) {
    newOptions.collectCoverageFrom = [];
  }

  if (!newOptions.findRelatedTests) {
    newOptions.findRelatedTests = false;
  }

  if (!newOptions.projects) {
    newOptions.projects = [];
  }

  if (!newOptions.extraGlobals) {
    newOptions.extraGlobals = [];
  }

  if (!newOptions.forceExit) {
    newOptions.forceExit = false;
  }

  if (!newOptions.logHeapUsage) {
    newOptions.logHeapUsage = false;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  }

  return {
    hasDeprecationWarnings,
    options: newOptions
  };
}
