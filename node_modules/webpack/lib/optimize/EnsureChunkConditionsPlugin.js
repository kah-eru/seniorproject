/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
<<<<<<< HEAD
"use strict";

const GraphHelpers = require("../GraphHelpers");

class EnsureChunkConditionsPlugin {
=======

"use strict";

const { STAGE_BASIC } = require("../OptimizationStages");

/** @typedef {import("../Chunk")} Chunk */
/** @typedef {import("../ChunkGroup")} ChunkGroup */
/** @typedef {import("../Compiler")} Compiler */

class EnsureChunkConditionsPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"EnsureChunkConditionsPlugin",
			compilation => {
<<<<<<< HEAD
				const handler = chunks => {
					let changed = false;
					for (const module of compilation.modules) {
						if (!module.chunkCondition) continue;
						const sourceChunks = new Set();
						const chunkGroups = new Set();
						for (const chunk of module.chunksIterable) {
							if (!module.chunkCondition(chunk)) {
=======
				/**
				 * @param {Iterable<Chunk>} chunks the chunks
				 */
				const handler = chunks => {
					const chunkGraph = compilation.chunkGraph;
					// These sets are hoisted here to save memory
					// They are cleared at the end of every loop
					/** @type {Set<Chunk>} */
					const sourceChunks = new Set();
					/** @type {Set<ChunkGroup>} */
					const chunkGroups = new Set();
					for (const module of compilation.modules) {
						if (!module.hasChunkCondition()) continue;
						for (const chunk of chunkGraph.getModuleChunksIterable(module)) {
							if (!module.chunkCondition(chunk, compilation)) {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
								sourceChunks.add(chunk);
								for (const group of chunk.groupsIterable) {
									chunkGroups.add(group);
								}
							}
						}
						if (sourceChunks.size === 0) continue;
<<<<<<< HEAD
=======
						/** @type {Set<Chunk>} */
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
						const targetChunks = new Set();
						chunkGroupLoop: for (const chunkGroup of chunkGroups) {
							// Can module be placed in a chunk of this group?
							for (const chunk of chunkGroup.chunks) {
<<<<<<< HEAD
								if (module.chunkCondition(chunk)) {
=======
								if (module.chunkCondition(chunk, compilation)) {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
									targetChunks.add(chunk);
									continue chunkGroupLoop;
								}
							}
							// We reached the entrypoint: fail
							if (chunkGroup.isInitial()) {
								throw new Error(
									"Cannot fullfil chunk condition of " + module.identifier()
								);
							}
							// Try placing in all parents
							for (const group of chunkGroup.parentsIterable) {
								chunkGroups.add(group);
							}
						}
						for (const sourceChunk of sourceChunks) {
<<<<<<< HEAD
							GraphHelpers.disconnectChunkAndModule(sourceChunk, module);
						}
						for (const targetChunk of targetChunks) {
							GraphHelpers.connectChunkAndModule(targetChunk, module);
						}
					}
					if (changed) return true;
				};
				compilation.hooks.optimizeChunksBasic.tap(
					"EnsureChunkConditionsPlugin",
					handler
				);
				compilation.hooks.optimizeExtractedChunksBasic.tap(
					"EnsureChunkConditionsPlugin",
=======
							chunkGraph.disconnectChunkAndModule(sourceChunk, module);
						}
						for (const targetChunk of targetChunks) {
							chunkGraph.connectChunkAndModule(targetChunk, module);
						}
						sourceChunks.clear();
						chunkGroups.clear();
					}
				};
				compilation.hooks.optimizeChunks.tap(
					{
						name: "EnsureChunkConditionsPlugin",
						stage: STAGE_BASIC
					},
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
					handler
				);
			}
		);
	}
}
module.exports = EnsureChunkConditionsPlugin;
