/**
 * @fileoverview Rule that warns about used warning comments
 * @author Alexander Schmidt <https://github.com/lxanders>
 */

"use strict";

<<<<<<< HEAD
const astUtils = require("../util/ast-utils");
=======
const escapeRegExp = require("escape-string-regexp");
const astUtils = require("./utils/ast-utils");

const CHAR_LIMIT = 40;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
<<<<<<< HEAD
            description: "disallow specified warning terms in comments",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-warning-comments"
=======
            description: "Disallow specified warning terms in comments",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-warning-comments"
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
        },

        schema: [
            {
                type: "object",
                properties: {
                    terms: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    },
                    location: {
                        enum: ["start", "anywhere"]
<<<<<<< HEAD
=======
                    },
                    decoration: {
                        type: "array",
                        items: {
                            type: "string",
                            pattern: "^\\S$"
                        },
                        minItems: 1,
                        uniqueItems: true
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
                    }
                },
                additionalProperties: false
            }
<<<<<<< HEAD
        ]
    },

    create(context) {

        const sourceCode = context.getSourceCode(),
            configuration = context.options[0] || {},
            warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
            location = configuration.location || "start",
=======
        ],

        messages: {
            unexpectedComment: "Unexpected '{{matchedTerm}}' comment: '{{comment}}'."
        }
    },

    create(context) {
        const sourceCode = context.sourceCode,
            configuration = context.options[0] || {},
            warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
            location = configuration.location || "start",
            decoration = [...configuration.decoration || []].join(""),
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
            selfConfigRegEx = /\bno-warning-comments\b/u;

        /**
         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified
         * location ("start" or "anywhere"). If the term starts or ends with non word characters, then the match will not
         * require word boundaries on that side.
<<<<<<< HEAD
         *
=======
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
         * @param {string} term A term to convert to a RegExp
         * @returns {RegExp} The term converted to a RegExp
         */
        function convertToRegExp(term) {
<<<<<<< HEAD
            const escaped = term.replace(/[-/\\$^*+?.()|[\]{}]/gu, "\\$&");
            const wordBoundary = "\\b";
            const eitherOrWordBoundary = `|${wordBoundary}`;
            let prefix;

            /*
             * If the term ends in a word character (a-z0-9_), ensure a word
             * boundary at the end, so that substrings do not get falsely
             * matched. eg "todo" in a string such as "mastodon".
             * If the term ends in a non-word character, then \b won't match on
             * the boundary to the next non-word character, which would likely
             * be a space. For example `/\bFIX!\b/.test('FIX! blah') === false`.
             * In these cases, use no bounding match. Same applies for the
             * prefix, handled below.
             */
            const suffix = /\w$/u.test(term) ? "\\b" : "";

            if (location === "start") {

                /*
                 * When matching at the start, ignore leading whitespace, and
                 * there's no need to worry about word boundaries.
                 */
                prefix = "^\\s*";
            } else if (/^\w/u.test(term)) {
                prefix = wordBoundary;
            } else {
                prefix = "";
            }

            if (location === "start") {

                /*
                 * For location "start" the regex should be
                 * ^\s*TERM\b.  This checks the word boundary
                 * at the beginning of the comment.
                 */
                return new RegExp(prefix + escaped + suffix, "i"); // eslint-disable-line require-unicode-regexp
            }

            /*
             * For location "anywhere" the regex should be
             * \bTERM\b|\bTERM\b, this checks the entire comment
             * for the term.
             */
            return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, "i"); // eslint-disable-line require-unicode-regexp
=======
            const escaped = escapeRegExp(term);
            const escapedDecoration = escapeRegExp(decoration);

            /*
             * When matching at the start, ignore leading whitespace, and
             * there's no need to worry about word boundaries.
             *
             * These expressions for the prefix and suffix are designed as follows:
             * ^   handles any terms at the beginning of a comment.
             *     e.g. terms ["TODO"] matches `//TODO something`
             * $   handles any terms at the end of a comment
             *     e.g. terms ["TODO"] matches `// something TODO`
             * \b  handles terms preceded/followed by word boundary
             *     e.g. terms: ["!FIX", "FIX!"] matches `// FIX!something` or `// something!FIX`
             *          terms: ["FIX"] matches `// FIX!` or `// !FIX`, but not `// fixed or affix`
             *
             * For location start:
             * [\s]* handles optional leading spaces
             *     e.g. terms ["TODO"] matches `//    TODO something`
             * [\s\*]* (where "\*" is the escaped string of decoration)
             *     handles optional leading spaces or decoration characters (for "start" location only)
             *     e.g. terms ["TODO"] matches `/**** TODO something ... `
             */
            const wordBoundary = "\\b";

            let prefix = "";

            if (location === "start") {
                prefix = `^[\\s${escapedDecoration}]*`;
            } else if (/^\w/u.test(term)) {
                prefix = wordBoundary;
            }

            const suffix = /\w$/u.test(term) ? wordBoundary : "";
            const flags = "iu"; // Case-insensitive with Unicode case folding.

            /*
             * For location "start", the typical regex is:
             *   /^[\s]*ESCAPED_TERM\b/iu.
             * Or if decoration characters are specified (e.g. "*"), then any of
             * those characters may appear in any order at the start:
             *   /^[\s\*]*ESCAPED_TERM\b/iu.
             *
             * For location "anywhere" the typical regex is
             *   /\bESCAPED_TERM\b/iu
             *
             * If it starts or ends with non-word character, the prefix and suffix are empty, respectively.
             */
            return new RegExp(`${prefix}${escaped}${suffix}`, flags);
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
        }

        const warningRegExps = warningTerms.map(convertToRegExp);

        /**
         * Checks the specified comment for matches of the configured warning terms and returns the matches.
         * @param {string} comment The comment which is checked.
         * @returns {Array} All matched warning terms for this comment.
         */
        function commentContainsWarningTerm(comment) {
            const matches = [];

            warningRegExps.forEach((regex, index) => {
                if (regex.test(comment)) {
                    matches.push(warningTerms[index]);
                }
            });

            return matches;
        }

        /**
         * Checks the specified node for matching warning comments and reports them.
         * @param {ASTNode} node The AST node being checked.
         * @returns {void} undefined.
         */
        function checkComment(node) {
<<<<<<< HEAD
            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {
                return;
            }

            const matches = commentContainsWarningTerm(node.value);

            matches.forEach(matchedTerm => {
                context.report({
                    node,
                    message: "Unexpected '{{matchedTerm}}' comment.",
                    data: {
                        matchedTerm
=======
            const comment = node.value;

            if (
                astUtils.isDirectiveComment(node) &&
                selfConfigRegEx.test(comment)
            ) {
                return;
            }

            const matches = commentContainsWarningTerm(comment);

            matches.forEach(matchedTerm => {
                let commentToDisplay = "";
                let truncated = false;

                for (const c of comment.trim().split(/\s+/u)) {
                    const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;

                    if (tmp.length <= CHAR_LIMIT) {
                        commentToDisplay = tmp;
                    } else {
                        truncated = true;
                        break;
                    }
                }

                context.report({
                    node,
                    messageId: "unexpectedComment",
                    data: {
                        matchedTerm,
                        comment: `${commentToDisplay}${
                            truncated ? "..." : ""
                        }`
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
                    }
                });
            });
        }

        return {
            Program() {
                const comments = sourceCode.getAllComments();

<<<<<<< HEAD
                comments.filter(token => token.type !== "Shebang").forEach(checkComment);
=======
                comments
                    .filter(token => token.type !== "Shebang")
                    .forEach(checkComment);
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
            }
        };
    }
};
