"use strict";
<<<<<<< HEAD
const HTMLElementImpl = require("./HTMLElement-impl").implementation;
const { stripAndCollapseASCIIWhitespace } = require("../helpers/strings");
const { domSymbolTree } = require("../helpers/internal-constants");
const { closest } = require("../helpers/traversal");

class HTMLOptionElementImpl extends HTMLElementImpl {
  constructor(args, privateData) {
    super(args, privateData);
=======

const HTMLElementImpl = require("./HTMLElement-impl").implementation;
const NODE_TYPE = require("../node-type");
const { stripAndCollapseASCIIWhitespace } = require("../helpers/strings");
const { domSymbolTree } = require("../helpers/internal-constants");
const { HTML_NS, SVG_NS } = require("../helpers/namespaces");
const { closest } = require("../helpers/traversal");
const { formOwner } = require("../helpers/form-controls");

class HTMLOptionElementImpl extends HTMLElementImpl {
  constructor(globalObject, args, privateData) {
    super(globalObject, args, privateData);
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

    // whenever selectedness is set to true, make sure all
    // other options set selectedness to false
    this._selectedness = false;
    this._dirtyness = false;
  }
<<<<<<< HEAD
=======

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  _removeOtherSelectedness() {
    // Remove the selectedness flag from all other options in this select
    const select = this._selectNode;

<<<<<<< HEAD
    if (select && !select.hasAttribute("multiple")) {
=======
    if (select && !select.hasAttributeNS(null, "multiple")) {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      for (const option of select.options) {
        if (option !== this) {
          option._selectedness = false;
        }
      }
    }
  }
<<<<<<< HEAD
=======

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  _askForAReset() {
    const select = this._selectNode;
    if (select) {
      select._askedForAReset();
    }
  }
<<<<<<< HEAD
  _attrModified(name) {
    if (!this._dirtyness && name === "selected") {
      this._selectedness = this.hasAttribute("selected");
=======

  _attrModified(name, value, oldValue) {
    if (!this._dirtyness && name === "selected") {
      this._selectedness = this.hasAttributeNS(null, "selected");
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      if (this._selectedness) {
        this._removeOtherSelectedness();
      }
      this._askForAReset();
    }
<<<<<<< HEAD
    super._attrModified.apply(this, arguments);
  }
=======
    super._attrModified(name, value, oldValue);
  }

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  get _selectNode() {
    let select = domSymbolTree.parent(this);
    if (!select) {
      return null;
    }

    if (select.nodeName.toUpperCase() !== "SELECT") {
      select = domSymbolTree.parent(select);
      if (!select || select.nodeName.toUpperCase() !== "SELECT") {
        return null;
      }
    }
    return select;
  }
<<<<<<< HEAD
  get form() {
    return closest(this, "form");
  }
  get text() {
    // TODO is not correctly excluding script and SVG script descendants
    return stripAndCollapseASCIIWhitespace(this.textContent);
  }
  set text(V) {
    this.textContent = V;
  }

  get value() {
    return this.hasAttribute("value") ? this.getAttribute("value") : this.text;
  }
  set value(val) {
    this.setAttribute("value", val);
  }
=======

  get form() {
    return formOwner(this);
  }

  get text() {
    return stripAndCollapseASCIIWhitespace(childTextContentExcludingDescendantsOfScript(this));
  }
  set text(value) {
    this.textContent = value;
  }

  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-value
  _getValue() {
    if (this.hasAttributeNS(null, "value")) {
      return this.getAttributeNS(null, "value");
    }

    return this.text;
  }

  get value() {
    return this._getValue();
  }
  set value(value) {
    this.setAttributeNS(null, "value", value);
  }

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  get index() {
    const select = closest(this, "select");
    if (select === null) {
      return 0;
    }

    return select.options.indexOf(this);
  }
<<<<<<< HEAD
=======

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  get selected() {
    return this._selectedness;
  }
  set selected(s) {
    this._dirtyness = true;
    this._selectedness = Boolean(s);
    if (this._selectedness) {
      this._removeOtherSelectedness();
    }
    this._askForAReset();
<<<<<<< HEAD
  }

  // TODO this is quite wrong
  get label() {
    if (this.hasAttribute("label")) {
      return this.getAttribute("label");
    }
    const select = this._selectNode;
    if (select) {
      return select.getAttribute("label");
    }
    return null;
  }

  set label(V) {
    const select = this._selectNode;
    if (select) {
      select.setAttribute("label", V);
    }
  }
=======
    this._modified();
  }

  get label() {
    if (this.hasAttributeNS(null, "label")) {
      return this.getAttributeNS(null, "label");
    }

    return this.text;
  }
  set label(value) {
    this.setAttributeNS(null, "label", value);
  }
}

function childTextContentExcludingDescendantsOfScript(root) {
  let text = "";
  for (const child of domSymbolTree.childrenIterator(root)) {
    if (child._localName === "script" && (child._namespaceURI === HTML_NS || child._namespaceURI === SVG_NS)) {
      continue;
    }

    if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {
      text += child.nodeValue;
    } else {
      text += childTextContentExcludingDescendantsOfScript(child);
    }
  }
  return text;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
}

module.exports = {
  implementation: HTMLOptionElementImpl
};
