/**
 * @fileoverview Prevent usage of unsafe lifecycle methods
 * @author Sergei Startsev
 */

'use strict';

<<<<<<< HEAD
const Components = require('../util/Components');
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');
const versionUtil = require('../util/version');
=======
const astUtil = require('../util/ast');
const componentUtil = require('../util/componentUtil');
const docsUrl = require('../util/docsUrl');
const testReactVersion = require('../util/version').testReactVersion;
const report = require('../util/report');
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

<<<<<<< HEAD
module.exports = {
  meta: {
    docs: {
      description: 'Prevent usage of unsafe lifecycle methods',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('no-unsafe')
    },
=======
const messages = {
  unsafeMethod: '{{method}} is unsafe for use in async rendering. Update the component to use {{newMethod}} instead. {{details}}',
};

module.exports = {
  meta: {
    docs: {
      description: 'Disallow usage of unsafe lifecycle methods',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('no-unsafe'),
    },

    messages,

>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    schema: [
      {
        type: 'object',
        properties: {
          checkAliases: {
            default: false,
<<<<<<< HEAD
            type: 'boolean'
          }
        },
        additionalProperties: false
      }
    ]
  },

  create: Components.detect((context, components, utils) => {
    const config = context.options[0] || {};
    const checkAliases = config.checkAliases || false;

    const isApplicable = versionUtil.testReactVersion(context, '16.3.0');
=======
            type: 'boolean',
          },
        },
        additionalProperties: false,
      },
    ],
  },

  create(context) {
    const config = context.options[0] || {};
    const checkAliases = config.checkAliases || false;

    const isApplicable = testReactVersion(context, '>= 16.3.0');
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    if (!isApplicable) {
      return {};
    }

    const unsafe = {
      UNSAFE_componentWillMount: {
        newMethod: 'componentDidMount',
        details:
<<<<<<< HEAD
          'See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html.'
=======
          'See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html.',
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      },
      UNSAFE_componentWillReceiveProps: {
        newMethod: 'getDerivedStateFromProps',
        details:
<<<<<<< HEAD
          'See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html.'
=======
          'See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html.',
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      },
      UNSAFE_componentWillUpdate: {
        newMethod: 'componentDidUpdate',
        details:
<<<<<<< HEAD
          'See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html.'
      }
=======
          'See https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html.',
      },
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    };
    if (checkAliases) {
      unsafe.componentWillMount = unsafe.UNSAFE_componentWillMount;
      unsafe.componentWillReceiveProps = unsafe.UNSAFE_componentWillReceiveProps;
      unsafe.componentWillUpdate = unsafe.UNSAFE_componentWillUpdate;
    }

    /**
     * Returns a list of unsafe methods
     * @returns {Array} A list of unsafe methods
     */
    function getUnsafeMethods() {
      return Object.keys(unsafe);
    }

    /**
     * Checks if a passed method is unsafe
     * @param {string} method Life cycle method
     * @returns {boolean} Returns true for unsafe methods, otherwise returns false
     */
    function isUnsafe(method) {
      const unsafeMethods = getUnsafeMethods();
      return unsafeMethods.indexOf(method) !== -1;
    }

    /**
     * Reports the error for an unsafe method
     * @param {ASTNode} node The AST node being checked
     * @param {string} method Life cycle method
     */
    function checkUnsafe(node, method) {
      if (!isUnsafe(method)) {
        return;
      }

      const meta = unsafe[method];
      const newMethod = meta.newMethod;
      const details = meta.details;

<<<<<<< HEAD
      context.report({
        node: node,
        message: `${method} is unsafe for use in async rendering. Update the component to use ${newMethod} instead. ${details}`
=======
      const propertyNode = astUtil.getComponentProperties(node)
        .find((property) => astUtil.getPropertyName(property) === method);

      report(context, messages.unsafeMethod, 'unsafeMethod', {
        node: propertyNode,
        data: {
          method,
          newMethod,
          details,
        },
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      });
    }

    /**
     * Returns life cycle methods if available
     * @param {ASTNode} node The AST node being checked.
     * @returns {Array} The array of methods.
     */
    function getLifeCycleMethods(node) {
      const properties = astUtil.getComponentProperties(node);
<<<<<<< HEAD
      return properties.map(property => astUtil.getPropertyName(property));
=======
      return properties.map((property) => astUtil.getPropertyName(property));
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    }

    /**
     * Checks life cycle methods
     * @param {ASTNode} node The AST node being checked.
     */
    function checkLifeCycleMethods(node) {
<<<<<<< HEAD
      if (utils.isES5Component(node) || utils.isES6Component(node)) {
        const methods = getLifeCycleMethods(node);
        methods.forEach(method => checkUnsafe(node, method));
=======
      if (componentUtil.isES5Component(node, context) || componentUtil.isES6Component(node, context)) {
        const methods = getLifeCycleMethods(node);
        methods
          .sort((a, b) => a.localeCompare(b))
          .forEach((method) => checkUnsafe(node, method));
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      }
    }

    return {
      ClassDeclaration: checkLifeCycleMethods,
      ClassExpression: checkLifeCycleMethods,
<<<<<<< HEAD
      ObjectExpression: checkLifeCycleMethods
    };
  })
=======
      ObjectExpression: checkLifeCycleMethods,
    };
  },
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
};
