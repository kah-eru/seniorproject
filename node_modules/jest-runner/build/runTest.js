'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = runTest;

<<<<<<< HEAD
function _console() {
  const data = require('@jest/console');

  _console = function _console() {
=======
function _chalk() {
  const data = _interopRequireDefault(require('chalk'));

  _chalk = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

<<<<<<< HEAD
function _gracefulFs() {
  const data = _interopRequireDefault(require('graceful-fs'));

  _gracefulFs = function _gracefulFs() {
    return data;
  };

  return data;
}

function _jestUtil() {
  const data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestLeakDetector() {
  const data = _interopRequireDefault(require('jest-leak-detector'));

  _jestLeakDetector = function _jestLeakDetector() {
    return data;
  };

  return data;
}

function _jestConfig() {
  const data = require('jest-config');

  _jestConfig = function _jestConfig() {
    return data;
  };

  return data;
}

function docblock() {
  const data = _interopRequireWildcard(require('jest-docblock'));

  docblock = function docblock() {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  const data = require('jest-message-util');

  _jestMessageUtil = function _jestMessageUtil() {
=======
function fs() {
  const data = _interopRequireWildcard(require('graceful-fs'));

  fs = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

function _sourceMapSupport() {
  const data = _interopRequireDefault(require('source-map-support'));

<<<<<<< HEAD
  _sourceMapSupport = function _sourceMapSupport() {
=======
  _sourceMapSupport = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

<<<<<<< HEAD
function _chalk() {
  const data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
=======
function _console() {
  const data = require('@jest/console');

  _console = function () {
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    return data;
  };

  return data;
}

<<<<<<< HEAD
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc =
            Object.defineProperty && Object.getOwnPropertyDescriptor
              ? Object.getOwnPropertyDescriptor(obj, key)
              : {};
          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }
    newObj.default = obj;
    return newObj;
  }
=======
function _transform() {
  const data = require('@jest/transform');

  _transform = function () {
    return data;
  };

  return data;
}

function docblock() {
  const data = _interopRequireWildcard(require('jest-docblock'));

  docblock = function () {
    return data;
  };

  return data;
}

function _jestLeakDetector() {
  const data = _interopRequireDefault(require('jest-leak-detector'));

  _jestLeakDetector = function () {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  const data = require('jest-message-util');

  _jestMessageUtil = function () {
    return data;
  };

  return data;
}

function _jestResolve() {
  const data = require('jest-resolve');

  _jestResolve = function () {
    return data;
  };

  return data;
}

function _jestUtil() {
  const data = require('jest-util');

  _jestUtil = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj};
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

<<<<<<< HEAD
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(
        Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        })
      );
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function() {
    var self = this,
      args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }
      _next(undefined);
    });
  };
}

function freezeConsole(testConsole, config) {
  // @ts-ignore: `_log` is `private` - we should figure out some proper API here
  testConsole._log = function fakeConsolePush(_type, message) {
    const error = new (_jestUtil()).ErrorWithStack(
=======
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
function freezeConsole(testConsole, config) {
  // @ts-expect-error: `_log` is `private` - we should figure out some proper API here
  testConsole._log = function fakeConsolePush(_type, message) {
    const error = new (_jestUtil().ErrorWithStack)(
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
      `${_chalk().default.red(
        `${_chalk().default.bold(
          'Cannot log after tests are done.'
        )} Did you forget to wait for something async in your test?`
      )}\nAttempted to log "${message}".`,
      fakeConsolePush
    );
    const formattedError = (0, _jestMessageUtil().formatExecError)(
      error,
      config,
      {
        noStackTrace: false
      },
      undefined,
      true
    );
<<<<<<< HEAD
    process.stderr.write('\n' + formattedError + '\n'); // TODO: set exit code in Jest 25
    // process.exitCode = 1;
=======
    process.stderr.write('\n' + formattedError + '\n');
    process.exitCode = 1;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
  };
} // Keeping the core of "runTest" as a separate function (as "runTestInternal")
// is key to be able to detect memory leaks. Since all variables are local to
// the function, when "runTestInternal" finishes its execution, they can all be
// freed, UNLESS something else is leaking them (and that's why we can detect
// the leak!).
//
// If we had all the code in a single function, we should manually nullify all
// references to verify if there is a leak, which is not maintainable and error
// prone. That's why "runTestInternal" CANNOT be inlined inside "runTest".

<<<<<<< HEAD
function runTestInternal(_x, _x2, _x3, _x4, _x5) {
  return _runTestInternal.apply(this, arguments);
}

function _runTestInternal() {
  _runTestInternal = _asyncToGenerator(function*(
    path,
    globalConfig,
    config,
    resolver,
    context
  ) {
    const testSource = _gracefulFs().default.readFileSync(path, 'utf8');

    const docblockPragmas = docblock().parse(docblock().extract(testSource));
    const customEnvironment = docblockPragmas['jest-environment'];
    let testEnvironment = config.testEnvironment;

    if (customEnvironment) {
      if (Array.isArray(customEnvironment)) {
        throw new Error(
          `You can only define a single test environment through docblocks, got "${customEnvironment.join(
            ', '
          )}"`
        );
      }

      testEnvironment = (0, _jestConfig().getTestEnvironment)(
        _objectSpread({}, config, {
          testEnvironment: customEnvironment
        })
      );
    }

    const TestEnvironment = (0, _jestUtil().interopRequireDefault)(
      require(testEnvironment)
    ).default;
    const testFramework =
      process.env.JEST_CIRCUS === '1'
        ? require('jest-circus/runner') // eslint-disable-line import/no-extraneous-dependencies
        : require(config.testRunner);
    const Runtime = config.moduleLoader
      ? require(config.moduleLoader)
      : require('jest-runtime');
    let runtime = undefined;
    const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;

    const consoleFormatter = (type, message) =>
      (0, _console().getConsoleOutput)(
        config.cwd,
        !!globalConfig.verbose, // 4 = the console call is buried 4 stack frames deep
        _console().BufferedConsole.write(
          [],
          type,
          message,
          4,
          runtime && runtime.getSourceMaps()
        )
      );

    let testConsole;

    if (globalConfig.silent) {
      testConsole = new (_console()).NullConsole(
        consoleOut,
        consoleOut,
        consoleFormatter
      );
    } else if (globalConfig.verbose) {
      testConsole = new (_console()).CustomConsole(
        consoleOut,
        consoleOut,
        consoleFormatter
      );
    } else {
      testConsole = new (_console()).BufferedConsole(
        () => runtime && runtime.getSourceMaps()
      );
    }

    const environment = new TestEnvironment(config, {
      console: testConsole,
      docblockPragmas,
      testPath: path
    });
    const leakDetector = config.detectLeaks
      ? new (_jestLeakDetector()).default(environment)
      : null;
    const cacheFS = {
      [path]: testSource
    };
    (0, _jestUtil().setGlobal)(environment.global, 'console', testConsole);
    runtime = new Runtime(config, environment, resolver, cacheFS, {
      changedFiles: context && context.changedFiles,
      collectCoverage: globalConfig.collectCoverage,
      collectCoverageFrom: globalConfig.collectCoverageFrom,
      collectCoverageOnlyFrom: globalConfig.collectCoverageOnlyFrom
    });
    const start = Date.now();
    const sourcemapOptions = {
      environment: 'node',
      handleUncaughtExceptions: false,
      retrieveSourceMap: source => {
        const sourceMaps = runtime && runtime.getSourceMaps();
        const sourceMapSource = sourceMaps && sourceMaps[source];

        if (sourceMapSource) {
          try {
            return {
              map: JSON.parse(
                _gracefulFs().default.readFileSync(sourceMapSource, 'utf8')
              ),
              url: source
            };
          } catch (e) {}
        }

        return null;
      }
    }; // For tests

    runtime
      .requireInternalModule(
        require.resolve('source-map-support'),
        'source-map-support'
      )
      .install(sourcemapOptions); // For runtime errors

    _sourceMapSupport().default.install(sourcemapOptions);

    if (
      environment.global &&
      environment.global.process &&
      environment.global.process.exit
    ) {
      const realExit = environment.global.process.exit;

      environment.global.process.exit = function exit(...args) {
        const error = new (_jestUtil()).ErrorWithStack(
          `process.exit called with "${args.join(', ')}"`,
          exit
        );
        const formattedError = (0, _jestMessageUtil().formatExecError)(
          error,
          config,
          {
            noStackTrace: false
          },
          undefined,
          true
        );
        process.stderr.write(formattedError);
        return realExit(...args);
      };
    }

    try {
      yield environment.setup();
      let result;

      try {
        result = yield testFramework(
          globalConfig,
          config,
          environment,
          runtime,
          path
        );
      } catch (err) {
        // Access stack before uninstalling sourcemaps
        err.stack;
        throw err;
      }

      freezeConsole(testConsole, config);
      const testCount =
        result.numPassingTests +
        result.numFailingTests +
        result.numPendingTests +
        result.numTodoTests;
      result.perfStats = {
        end: Date.now(),
        start
      };
      result.testFilePath = path;
      result.console = testConsole.getBuffer();
      result.skipped = testCount === result.numPendingTests;
      result.displayName = config.displayName;
      const coverage = runtime.getAllCoverageInfoCopy();

      if (coverage) {
        const coverageKeys = Object.keys(coverage);

        if (coverageKeys.length) {
          result.coverage = coverage;
          result.sourceMaps = runtime.getSourceMapInfo(new Set(coverageKeys));
        }
      }

      if (globalConfig.logHeapUsage) {
        if (global.gc) {
          global.gc();
        }

        result.memoryUsage = process.memoryUsage().heapUsed;
      } // Delay the resolution to allow log messages to be output.

      return new Promise(resolve => {
        setImmediate(() =>
          resolve({
            leakDetector,
            result
          })
        );
      });
    } finally {
      yield environment.teardown();

      _sourceMapSupport().default.resetRetrieveHandlers();
    }
  });
  return _runTestInternal.apply(this, arguments);
}

function runTest(_x6, _x7, _x8, _x9, _x10) {
  return _runTest.apply(this, arguments);
}

function _runTest() {
  _runTest = _asyncToGenerator(function*(
=======
async function runTestInternal(
  path,
  globalConfig,
  config,
  resolver,
  context,
  sendMessageToJest
) {
  const testSource = fs().readFileSync(path, 'utf8');
  const docblockPragmas = docblock().parse(docblock().extract(testSource));
  const customEnvironment = docblockPragmas['jest-environment'];
  let testEnvironment = config.testEnvironment;

  if (customEnvironment) {
    if (Array.isArray(customEnvironment)) {
      throw new Error(
        `You can only define a single test environment through docblocks, got "${customEnvironment.join(
          ', '
        )}"`
      );
    }

    testEnvironment = (0, _jestResolve().resolveTestEnvironment)({
      ...config,
      requireResolveFunction: require.resolve,
      testEnvironment: customEnvironment
    });
  }

  const cacheFS = new Map([[path, testSource]]);
  const transformer = await (0, _transform().createScriptTransformer)(
    config,
    cacheFS
  );
  const TestEnvironment = await transformer.requireAndTranspileModule(
    testEnvironment
  );
  const testFramework = await transformer.requireAndTranspileModule(
    process.env.JEST_JASMINE === '1'
      ? require.resolve('jest-jasmine2')
      : config.testRunner
  );
  const Runtime = (0, _jestUtil().interopRequireDefault)(
    config.moduleLoader ? require(config.moduleLoader) : require('jest-runtime')
  ).default;
  const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;

  const consoleFormatter = (type, message) =>
    (0, _console().getConsoleOutput)(
      // 4 = the console call is buried 4 stack frames deep
      _console().BufferedConsole.write([], type, message, 4),
      config,
      globalConfig
    );

  let testConsole;

  if (globalConfig.silent) {
    testConsole = new (_console().NullConsole)(
      consoleOut,
      consoleOut,
      consoleFormatter
    );
  } else if (globalConfig.verbose) {
    testConsole = new (_console().CustomConsole)(
      consoleOut,
      consoleOut,
      consoleFormatter
    );
  } else {
    testConsole = new (_console().BufferedConsole)();
  }

  const environment = new TestEnvironment(config, {
    console: testConsole,
    docblockPragmas,
    testPath: path
  });

  if (typeof environment.getVmContext !== 'function') {
    console.error(
      `Test environment found at "${testEnvironment}" does not export a "getVmContext" method, which is mandatory from Jest 27. This method is a replacement for "runScript".`
    );
    process.exit(1);
  }

  const leakDetector = config.detectLeaks
    ? new (_jestLeakDetector().default)(environment)
    : null;
  (0, _jestUtil().setGlobal)(environment.global, 'console', testConsole);
  const runtime = new Runtime(
    config,
    environment,
    resolver,
    transformer,
    cacheFS,
    {
      changedFiles:
        context === null || context === void 0 ? void 0 : context.changedFiles,
      collectCoverage: globalConfig.collectCoverage,
      collectCoverageFrom: globalConfig.collectCoverageFrom,
      collectCoverageOnlyFrom: globalConfig.collectCoverageOnlyFrom,
      coverageProvider: globalConfig.coverageProvider,
      sourcesRelatedToTestsInChangedFiles:
        context === null || context === void 0
          ? void 0
          : context.sourcesRelatedToTestsInChangedFiles
    },
    path
  );
  const start = Date.now();

  for (const path of config.setupFiles) {
    const esm = runtime.unstable_shouldLoadAsEsm(path);

    if (esm) {
      await runtime.unstable_importModule(path);
    } else {
      runtime.requireModule(path);
    }
  }

  const sourcemapOptions = {
    environment: 'node',
    handleUncaughtExceptions: false,
    retrieveSourceMap: source => {
      var _runtime$getSourceMap;

      const sourceMapSource =
        (_runtime$getSourceMap = runtime.getSourceMaps()) === null ||
        _runtime$getSourceMap === void 0
          ? void 0
          : _runtime$getSourceMap.get(source);

      if (sourceMapSource) {
        try {
          return {
            map: JSON.parse(fs().readFileSync(sourceMapSource, 'utf8')),
            url: source
          };
        } catch {}
      }

      return null;
    }
  }; // For tests

  runtime
    .requireInternalModule(
      require.resolve('source-map-support'),
      'source-map-support'
    )
    .install(sourcemapOptions); // For runtime errors

  _sourceMapSupport().default.install(sourcemapOptions);

  if (
    environment.global &&
    environment.global.process &&
    environment.global.process.exit
  ) {
    const realExit = environment.global.process.exit;

    environment.global.process.exit = function exit(...args) {
      const error = new (_jestUtil().ErrorWithStack)(
        `process.exit called with "${args.join(', ')}"`,
        exit
      );
      const formattedError = (0, _jestMessageUtil().formatExecError)(
        error,
        config,
        {
          noStackTrace: false
        },
        undefined,
        true
      );
      process.stderr.write(formattedError);
      return realExit(...args);
    };
  } // if we don't have `getVmContext` on the env skip coverage

  const collectV8Coverage =
    globalConfig.coverageProvider === 'v8' &&
    typeof environment.getVmContext === 'function';

  try {
    await environment.setup();
    let result;

    try {
      if (collectV8Coverage) {
        await runtime.collectV8Coverage();
      }

      result = await testFramework(
        globalConfig,
        config,
        environment,
        runtime,
        path,
        sendMessageToJest
      );
    } catch (err) {
      // Access stack before uninstalling sourcemaps
      err.stack;
      throw err;
    } finally {
      if (collectV8Coverage) {
        await runtime.stopCollectingV8Coverage();
      }
    }

    freezeConsole(testConsole, config);
    const testCount =
      result.numPassingTests +
      result.numFailingTests +
      result.numPendingTests +
      result.numTodoTests;
    const end = Date.now();
    const testRuntime = end - start;
    result.perfStats = {
      end,
      runtime: testRuntime,
      slow: testRuntime / 1000 > config.slowTestThreshold,
      start
    };
    result.testFilePath = path;
    result.console = testConsole.getBuffer();
    result.skipped = testCount === result.numPendingTests;
    result.displayName = config.displayName;
    const coverage = runtime.getAllCoverageInfoCopy();

    if (coverage) {
      const coverageKeys = Object.keys(coverage);

      if (coverageKeys.length) {
        result.coverage = coverage;
      }
    }

    if (collectV8Coverage) {
      const v8Coverage = runtime.getAllV8CoverageInfoCopy();

      if (v8Coverage && v8Coverage.length > 0) {
        result.v8Coverage = v8Coverage;
      }
    }

    if (globalConfig.logHeapUsage) {
      if (global.gc) {
        global.gc();
      }

      result.memoryUsage = process.memoryUsage().heapUsed;
    } // Delay the resolution to allow log messages to be output.

    return new Promise(resolve => {
      setImmediate(() =>
        resolve({
          leakDetector,
          result
        })
      );
    });
  } finally {
    runtime.teardown();
    await environment.teardown();

    _sourceMapSupport().default.resetRetrieveHandlers();
  }
}

async function runTest(
  path,
  globalConfig,
  config,
  resolver,
  context,
  sendMessageToJest
) {
  const {leakDetector, result} = await runTestInternal(
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
    path,
    globalConfig,
    config,
    resolver,
<<<<<<< HEAD
    context
  ) {
    const _ref = yield runTestInternal(
        path,
        globalConfig,
        config,
        resolver,
        context
      ),
      leakDetector = _ref.leakDetector,
      result = _ref.result;

    if (leakDetector) {
      // We wanna allow a tiny but time to pass to allow last-minute cleanup
      yield new Promise(resolve => setTimeout(resolve, 100)); // Resolve leak detector, outside the "runTestInternal" closure.

      result.leaks = leakDetector.isLeaking();
    } else {
      result.leaks = false;
    }

    return result;
  });
  return _runTest.apply(this, arguments);
=======
    context,
    sendMessageToJest
  );

  if (leakDetector) {
    // We wanna allow a tiny but time to pass to allow last-minute cleanup
    await new Promise(resolve => setTimeout(resolve, 100)); // Resolve leak detector, outside the "runTestInternal" closure.

    result.leaks = await leakDetector.isLeaking();
  } else {
    result.leaks = false;
  }

  return result;
>>>>>>> 21d7be62d554915787485641c4ea1187492767dd
}
